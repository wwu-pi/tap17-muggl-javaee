package de.wwu.muggl.vm.initialization;

import java.util.Hashtable;

import javax.persistence.EntityManager;
import javax.transaction.UserTransaction;

import de.wwu.muggl.instructions.MethodResolutionError;
import de.wwu.muggl.jpa.FindResult;
import de.wwu.muggl.symbolic.jpa.MugglEntityManager;
import de.wwu.muggl.symbolic.jpa.var.SymbolicEntityManager;
import de.wwu.muggl.vm.VirtualMachine;
import de.wwu.muggl.vm.classfile.ClassFile;
import de.wwu.muggl.vm.classfile.ClassFileException;
import de.wwu.muggl.vm.classfile.structures.Attribute;
import de.wwu.muggl.vm.classfile.structures.Constant;
import de.wwu.muggl.vm.classfile.structures.Field;
import de.wwu.muggl.vm.classfile.structures.Method;
import de.wwu.muggl.vm.classfile.structures.attributes.AttributeRuntimeVisibleAnnotations;
import de.wwu.muggl.vm.classfile.structures.attributes.elements.Annotation;
import de.wwu.muggl.vm.impl.jpa.JPAVirtualMachine;

/**
 * This class represents a statically initialized ClassFile. It is used to offer access to the
 * static fields of the classes currently loaded by the virtual machine. It also can supply
 * instances of Objectref, which represent reference values which can be used for full
 * instantiation of ClassFiles.<br />
 * <br />
 * Using the public constructor will lead to the static initialization of the class. This
 * especially includes invocation of the <clinit>-Method, if there is any. Concrete instances
 * can then be derived by using getANewInstance(). An instance generated by getANewInstance()
 * is the representation of an object in this virtual machine implementation.<br />
 * <br />
 * An analogy for clarification:<br />
 * <table>
 * <tr><th>Suns JVM</th><th>Muggl</th></tr>
 * <tr><td>*.class-file</td><td>ClassFile: Offering the representation of the class' structures</td></tr>
 * <tr><td>Class</td><td>InitializedClass: Offering an statically initialized class.</td></tr>
 * <tr><td>Object</td><td>Objectref: Offering an instantiated class, as well as reference to its static fields.</td></tr>
 * </table>
 *
 * @author Tim Majchrzak
 * @version 1.0.0, 2010-03-10
 */
public class InitializedClass extends FieldContainer {
	// The only field - the represented ClassFile.
	private ClassFile representedClassFile;
	private VirtualMachine initByVM;

	/**
	 * Generate a statically initialized class. This leads to the execution of the <clinit>-Method
	 * (if there is any) to initialize static fields.
	 * @param representedClassFile The ClassFile represented.
	 * @param vm The currently running virtual machine.
	 * @throws ExceptionInInitializerError If class initialization failed.
	 */
	public InitializedClass(ClassFile representedClassFile, VirtualMachine vm) {
		// Invoke the super constructor.
		super();

		this.initByVM = vm;
		
		// Set the represented ClassFile.
		this.representedClassFile = representedClassFile;

		// If there is a super class, it has to be initialized first.
		if (this.representedClassFile.getSuperClass() != 0) {
			ClassFile superClassFile;
			try {
				superClassFile = this.representedClassFile.getClassLoader().getClassAsClassFile(this.representedClassFile.getConstantPool()[this.representedClassFile.getSuperClass()].getStringValue());
			} catch (ClassFileException e) {
				throw new ExceptionInInitializerError("Class initialization failed with a ClassFileException with the message: " + e.getMessage() + ".");
			}
			superClassFile.getTheInitializedClass(vm);
		}

		// Before invoking the static initializer, set the field for this instance in ClassFile.
		this.representedClassFile.putInitializedClass(this);

		// Check if there is a current frame at all, since this initialization might be done with the virtual machine startup.
		if (vm.getCurrentFrame() != null) //  && !vm.getCurrentFrame().getMethod().getName().equals("<clinit>") TODO this can be dropped, can it?
		{
			Method method = null;
			try {
				method = representedClassFile.getClinitMethod();
			} catch (MethodResolutionError e) {
				// Do nothing, this is an expected error.
			}

			// Execute <clinit>?
			if (method != null) {
				vm.executeTheCurrentFrameForClassInitialization(method);
			}
		}

		// Some classes need special a special initialization to work correctly in this application.
		specialInitialization(vm);
	}

	/**
	 * For wrapping reasons, some ClassFiles need a special initialization. This method
	 * checks if this applies for the represented ClassFile and takes the required
	 * actions.
	 * @param vm The currently running virtual machine.
	 * @throws ExceptionInInitializerError If special class initialization failed.
	 */
	private void specialInitialization(VirtualMachine vm) {
		try {
			// For java.lang.System, set special PrintStream for out and err.
			if (this.representedClassFile.getName().equals("java.lang.System")) {
				// Get the fields for the err and the out object.
				Field errField = this.representedClassFile.getFieldByNameAndDescriptor("err",
						"Ljava/io/PrintStream;");
				Field outField = this.representedClassFile.getFieldByNameAndDescriptor("out",
						"Ljava/io/PrintStream;");

				// Instantiate the wrapper.
				Objectref wrapperForErr = vm
						.getAnObjectref(this.representedClassFile.getClassLoader()
								.getClassAsClassFile("de.wwu.muggl.vm.execution.nativeWrapping.PrintStreamWrapper"));
				Objectref wrapperForOut = vm
						.getAnObjectref(this.representedClassFile.getClassLoader()
								.getClassAsClassFile("de.wwu.muggl.vm.execution.nativeWrapping.PrintStreamWrapper"));

				// Put the wrapper.
				this.fields.put(errField, wrapperForErr);
				this.fields.put(outField, wrapperForOut);

				/*
				 * Set the special field of the wrapper to preserve the information whether err or
				 * out was used.
				 */
				Field wrapperForField = wrapperForErr.getInitializedClass().getClassFile()
							.getFieldByNameAndDescriptor("wrapperFor", "Ljava/lang/String;");
				wrapperForErr.putField(wrapperForField, "java.lang.System.err");
				wrapperForOut.putField(wrapperForField, "java.lang.System.out");
			}
		} catch (ClassFileException e) {
			throw new ExceptionInInitializerError(
					"Initialization of the System.err/System.out-Wrapper "
					+ " failed with a ClassFileException with message: " + e.getMessage() + ".");
		}
	}
	
//	private void specialJavaEEInitialization() {
//		specialJavaEEDependencyInjection();
//	}
//	
//	private void specialJavaEEDependencyInjection() {
//		Constant[] constantPool = this.representedClassFile.getConstantPool();
//		for(Field field : this.representedClassFile.getFields()) {
//			for (Attribute attribute : field.getAttributes()) {
//				if (attribute.getStructureName().equals("attribute_runtime_visible_annotation")) {
//					AttributeRuntimeVisibleAnnotations attributeAnnotation = (AttributeRuntimeVisibleAnnotations) attribute;
//					if (constantPool[attributeAnnotation.getAnnotations()[0].getTypeIndex()].getStringValue().equals("Ljavax/persistence/PersistenceContext;")) {
//						this.fields.put(field, new String("This is a nice entity manager object")); // TODO: instead of string, put wrapper object 
//					}
//				}
//			}
//		}
//	}
	
	protected void initializeJavaEEDependencyInjections(Objectref objectRef) {
		injectEntityManager(objectRef);
		injectBeans(objectRef);
//		doPostConstruct(objectRef);
	}
	
	private void injectBeans(Objectref objectRef) {
		Constant[] constantPool = this.representedClassFile.getConstantPool();
		for(Field field : this.representedClassFile.getFields()) {
			if(field.getType().equals(EntityManager.class.getName()) || field.getType().equals(UserTransaction.class.getName())) {
				continue;
			}
			
			for (Attribute attribute : field.getAttributes()) {
				if(attribute instanceof AttributeRuntimeVisibleAnnotations) {
					AttributeRuntimeVisibleAnnotations attributeAnnotation = (AttributeRuntimeVisibleAnnotations) attribute;
					
					for(Annotation annotation : attributeAnnotation.getAnnotations()) {
						String annoName = constantPool[annotation.getTypeIndex()].getStringValue();
						
						if (annoName.equals("Ljavax/inject/Inject;")) {
							try {
								ClassFile beanClassFile = this.initByVM.getClassLoader().getClassAsClassFile(field.getType());
								Objectref beanObjectRef = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(field.getType());
								if(beanObjectRef == null) {
									// bean has not yet been created
									// that is, bean is not in bean instance pool yet
									beanObjectRef = this.initByVM.getAnObjectref(beanClassFile);
								} 
								objectRef.fields.put(field, beanObjectRef);
							} catch(ClassFileException e) {
								throw new RuntimeException(e);
							}
						}
						
						else if (annoName.equals("Ljavax/annotation/Resource;")) {
							String resourceConfigName = annotation.getElementValuePairs()[0].getElementValues().getStringValue();
							String fieldType = 	field.getType();
							
							System.out.println("Get type: " +fieldType + " with config name="+ resourceConfigName + " for object ref: "+ objectRef.getObjectType());
							
							Objectref cachedBeanObjectref = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(fieldType);
							
							if(cachedBeanObjectref != null) {
								objectRef.fields.put(field, cachedBeanObjectref);
							} else {
								ClassFile beanClassFileName = ((JPAVirtualMachine)this.initByVM).getSpringBean(fieldType, resourceConfigName);
								if(beanClassFileName != null) {
									Objectref cached = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(beanClassFileName.getName());
									if(cached != null) {
										objectRef.fields.put(field, cached);
									} else {
										Objectref beanObjectref = ((JPAVirtualMachine)this.initByVM).getAnObjectref(beanClassFileName);
										((JPAVirtualMachine)this.initByVM).addObjectrefToBeanInstancePool(beanObjectref);
										objectRef.fields.put(field, beanObjectref);
									}
								}
							}
							
//							
//							
//							
//							Objectref cachedBeanObjectref = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(fieldType);
//							
//							ClassFile beanClassFile = ((JPAVirtualMachine)this.initByVM).getSpringBean(fieldType, resourceConfigName);
//							if(beanClassFile != null && beanClassFile.isAccInterface() && cachedBeanObjectref == null) {
//								cachedBeanObjectref = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(fieldType+"Impl");
//							}
//							
//							if(cachedBeanObjectref != null) {
//								objectRef.fields.put(field, cachedBeanObjectref);
//							} else {
//								
//								if(beanClassFile != null) {
//									Objectref beanObjectRef = ((JPAVirtualMachine)this.initByVM).getBeanFromPool(field.getType());
//									if(beanObjectRef == null) {
//										// bean has not yet been created
//										// that is, bean is not in bean instance pool yet
//										beanObjectRef = this.initByVM.getAnObjectref(beanClassFile);
//									} 
//									objectRef.fields.put(field, beanObjectRef);
//								}
//							}
							
						}
					}
				}
			}
		}
	}
	
	
	private void injectEntityManager(Objectref objectRef) {
		Constant[] constantPool = this.representedClassFile.getConstantPool();
		for(Field field : this.representedClassFile.getFields()) {
			for (Attribute attribute : field.getAttributes()) {
				if (attribute.getStructureName().equals("attribute_runtime_visible_annotation")) {
					AttributeRuntimeVisibleAnnotations attributeAnnotation = (AttributeRuntimeVisibleAnnotations) attribute;
					for(Annotation annotation : attributeAnnotation.getAnnotations()) {
						String annoName = constantPool[annotation.getTypeIndex()].getStringValue();
						if ( (annoName.equals("Ljavax/persistence/PersistenceContext;") && field.getType().equals("javax.persistence.EntityManager"))
							|| (annoName.equals("Ljavax/inject/Inject;") && field.getType().equals("javax.persistence.EntityManager"))) {
							if(this.initByVM instanceof JPAVirtualMachine) {
								JPAVirtualMachine jpaVM = (JPAVirtualMachine)this.initByVM;
								objectRef.fields.put(field, jpaVM.getMugglEntityManager());
							}
						}
						
						else if(annoName.equals("Ljavax/inject/Inject;") && field.getType().equals("javax.transaction.UserTransaction")) {
							if(this.initByVM instanceof JPAVirtualMachine) {
								JPAVirtualMachine jpaVM = (JPAVirtualMachine)this.initByVM;
								objectRef.fields.put(field, jpaVM.getMugglUserTransaction());
							}
						}
					}
				}
			}
		}
	}
	

	/**
	 * Getter for the ClassFile that is represented.
	 * @return The ClassFile that is represented.
	 */
	public ClassFile getClassFile() {
		return this.representedClassFile;
	}

	/**
	 * Return a String representation of the represented ClassFile.
	 * @return A String representation of the represented ClassFile.
	 */
	@Override
	public String toString() {
		return "Static reference of " + this.representedClassFile.getName();
	}

	/**
	 * Get a new instance of this InitializedClass. It will contain a reference to
	 * the InitializedClass generated by the ClassFile, which is responsible for
	 * the management of static fields.
	 * @return A new instance of this Objectref.
	 */
	public Objectref getANewInstance() {
		Objectref objectRef = new Objectref(this, false);
		if(this.initByVM instanceof JPAVirtualMachine) {
			((JPAVirtualMachine)this.initByVM).addObjectrefToBeanInstancePool(objectRef);
		}
		initializeJavaEEDependencyInjections(objectRef);
		return objectRef;
	}
	
	/**
	 * Get a new instance of this InitializedClass that will work as a wrapper
	 * for a primitive type. Only the following ClassFiles might be initialized
	 * as a primitive wrapper:
	 * java.lang.Boolean
	 * java.lang.Byte
	 * java.lang.Character
	 * java.lang.Double
	 * java.lang.Float
	 * java.lang.Integer
	 * java.lang.Long
	 * java.lang.Short
	 *
	 * @return A new instance of this Objectref acting as a wrapper for primitive types.
	 * @throws PrimitiveWrappingImpossibleException If the represented ClassFile cannot be used as a primitive wrapper.
	 */
	public Objectref getANewPrimitiveWrapper() throws PrimitiveWrappingImpossibleException {
		String name = this.representedClassFile.getName();
		if (!(name.equals("java.lang.Boolean")) && !(name.equals("java.lang.Byte"))
				&& !(name.equals("java.lang.Character")) && !(name.equals("java.lang.Double"))
				&& !(name.equals("java.lang.Float")) && !(name.equals("java.lang.Integer"))
				&& !(name.equals("java.lang.Long")) && !(name.equals("java.lang.Short"))
				&& !(name.equals("java.lang.String")))
			throw new PrimitiveWrappingImpossibleException("This ClassFile cannot be used to wrap a primitive type.");
		return new Objectref(this, true);
	}

	/**
	 * Getter for the static fields.
	 *
	 * @return The static fields Hashtable.
	 */
	public Hashtable<Field, Object> getStaticFields() {
		return this.fields;
	}
}
