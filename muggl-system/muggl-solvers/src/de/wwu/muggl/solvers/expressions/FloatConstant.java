package de.wwu.muggl.solvers.expressions;

/**
 * @author Christoph Lembeck
 */
public class FloatConstant extends NumericConstant implements Comparable<Constant>{

    /**
     * The constant representing the float value 1.
     */
    public static final FloatConstant ONE = new FloatConstant(1f);

    /**
     * The constant representing the float value 2.
     */
    public static final FloatConstant TWO = new FloatConstant(2f);

    /**
     * The constant representing the float value 0.
     */
    public static final FloatConstant ZERO = new FloatConstant(0f);

    /**
     * Creates a new FloatConstant object representing the passed float value.
     * @param value the number that should be represented by this object.
     * @return the new FloatConstant object representing the passed number.
     */
    public static FloatConstant getInstance(float value){
	return new FloatConstant(value);
    }

    /**
     * Stores the internal float value of this constant.
     */
    protected float value;

    /**
     * Creates a new FloatConstant object representing the passed float value.
     * This constructor should only be called using the static method
     * getInstance to avoid multiple generation of constants representing the same
     * values.
     * @param value the number that should be represented by this constant object.
     * @see #getInstance(float)
     */
    protected FloatConstant(float value){
	this.value = value;
    }

    @Override
    public NumericConstant abs(){
	if (value < 0)
	    return getInstance(-value);
	return this;
    }

    /**
     * Adds the passed constant to this constant.
     * @param addend the constant that should be added.
     * @return the sum of the two constants.
     */
    @Override
    public NumericConstant add(NumericConstant addend) {
	if (addend instanceof DoubleConstant)
	    return addend.add(this);
	else
	    return getInstance(this.value + addend.getFloatValue());
    }

    /**
     * Throws an InternalError because there is no conjunction operation for
     * floating point values defined in the java virtual machine specification.
     * @param constant unused.
     * @return nothing.
     * @throws InternalError
     */
    @Override
    public NumericConstant and(NumericConstant constant){
	throw new InternalError("& can not be applied to float and " + Term.getTypeName(constant.getType()));
    }

    @Override
    public NumericConstant arithmeticShiftRight(int range) {
	throw new InternalError("Shifting not supported on floating point values");
    }

    /**
     * Transforms this constant into a constant having the passed type.
     * @param type the type into which the constant should be casted using the
     * type representation specified in the interface Expression.
     * @return a constant of the passed type representing the number that will
     * be generated by a real java typecast.
     * @see de.wwu.muggl.solvers.expressions.Expression
     */
    @Override
    public NumericConstant castTo(byte type) {
	switch (type){
	case Expression.BYTE:
	    return IntConstant.getInstance((byte)value);
	case Expression.CHAR:
	    return IntConstant.getInstance((char)value);
	case Expression.SHORT:
	    return IntConstant.getInstance((short)value);
	case Expression.INT:
	    return IntConstant.getInstance((int)value);
	case Expression.LONG:
	    return LongConstant.getInstance((long)value);
	case Expression.FLOAT:
	    return this;
	case Expression.DOUBLE:
	    return DoubleConstant.getInstance(value);
	default:
	    throw new IllegalArgumentException("unkown type");
	}
    }

    /**
     * Compares the internal stored value of this FloatConstant with the passed
     * object.
     * @param obj the object this constant should be compared with.
     * @return a negative number if the internally stored value of this constant
     * is smaller than the stored value inside the passed object, zero if both
     * values are equal and a positive number if this numbre is greater than the
     * value of the passed constant.
     */
    public int compareTo(Constant obj) {
	if (obj instanceof FloatConstant){
	    return new Float(value).compareTo(new Float(((FloatConstant)obj).value));
	} else
	    throw new ClassCastException();
    }

    /**
     * Divides this constant by the passed one and returns the result.
     * @param divisor the constant that should be added.
     * @return the quotient sum of this constant and the argument.
     */
    @Override
    public NumericConstant divide(NumericConstant divisor) {
	if (divisor instanceof DoubleConstant)
	    return DoubleConstant.getInstance(getDoubleValue() / divisor.getDoubleValue());
	else
	    return getInstance(this.value / divisor.getFloatValue());
    }

    /**
     * Checks whether the passed object is equal to this constant.
     * @param obj the other object this constant should be compared to.
     * @return <i>true</i> if the passed object is a FloatConstant too and
     * represents the same number as this constant.
     */
    @Override
    public boolean equals(Object obj){
	return (obj == this) || ((obj instanceof FloatConstant) && (((FloatConstant)obj).value == value));
    }

    /**
     * Returns the value of this constant as a double.
     * @return the numeric value represented by this constant after conversion to
     * type double.
     */
    @Override
    public double getDoubleValue() {
	return value;
    }

    /**
     * Returns the value of this constant as a float.
     * @return the numeric value represented by this constant after conversion to
     * type float.
     */
    @Override
    public float getFloatValue(){
	return value;
    }

    /**
     * Returns the value of this constant as a int.
     * @return the numeric value represented by this constant after conversion to
     * type int.
     */
    @Override
    public int getIntValue() {
	return (int)value;
    }

    /**
     * Returns the value of this constant as a long.
     * @return the numeric value represented by this constant after conversion to
     * type long.
     */
    @Override
    public long getLongValue() {
	return (long)value;
    }

    /**
     * Returns the type of the actual expression. Here it will be
     * <i>Expression.FLOAT</i>.
     * @return <i>Expression.FLOAT</i>.
     * @see de.wwu.muggl.solvers.expressions.Expression#FLOAT
     */
    public byte getType() {
	return Expression.FLOAT;
    }

    /**
     * Returns the internal stored float value of this constant.
     * @return the internal stored float value of this constant.
     */
    public float getValue(){
	return value;
    }

    /**
     * Calculates a hash code value for this constant object.
     * @return the hash code value for this constant object.
     */
    @Override
    public int hashCode(){
	return Float.floatToIntBits(value);
    }

    /**
     * Checks whether the value represented by this constant is numeric equal to
     * the value represented by the other constant.
     * @param arg the other constant, whose value should be compared to this one.
     * @return <code>true</code> if the value rpresented by this constant is equal
     * to the value of the other constant.
     */
    @Override
    public boolean isEqualTo(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value == arg.getDoubleValue();
	else
	    return value == arg.getFloatValue();
    }

    /**
     * Checks whether the constant is greater than or equal to the passed
     * argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is greater than or equal to the
     * passed argument, <i>false</i> otherwise.
     */
    @Override
    public boolean isGreaterOrEqual(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value >= arg.getDoubleValue();
	    else
		return value >= arg.getFloatValue();
    }

    /**
     * Checks whether the constant is greater than the passed argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is greater than the passed argument,
     * <i>false</i> otherwise.
     */
    @Override
    public boolean isGreaterThan(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value > arg.getDoubleValue();
	    else
		return value > arg.getFloatValue();
    }

    /**
     * Returns <code>false</code> because float values havo no integer type.
     * @return <code>false</code>.
     */
    @Override
    public boolean isInteger(){
	return false;
    }

    /**
     * Checks whether the constant is lesser than or equal to the passed
     * argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is lesser than or equal to the
     * passed argument, <i>false</i> otherwise.
     */
    @Override
    public boolean isLesserOrEqual(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value <= arg.getDoubleValue();
	else
	    return value <= arg.getFloatValue();
    }

    /**
     * Checks whether the constant is lesser than the passed argument.
     * @param arg the constant this constant should be compared to.
     * @return <i>true</i> if this constant is lesser than the passed argument,
     * <i>false</i> otherwise.
     */
    @Override
    public boolean isLesserThan(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value < arg.getDoubleValue();
	else
	    return value < arg.getFloatValue();
    }

    /**
     * Checks if this constant is equal to the constant value minus one.
     * @return <i>true</i> if this constant is equal to minus one, <i>false</i>
     * otherwise.
     */
    @Override
    public boolean isMinusOne() {
	return value == -1f;
    }

    /**
     * Checks if this constant is lesser than zero or not.
     * @return <i>true</i> if this constant is lesser than the constant zero,
     * <i>false</i> otherwise.
     */
    @Override
    public boolean isNegative() {
	return value < 0f;
    }

    /**
     * Checks if this constant is lesser than or equal to zero or not.
     * @return <i>true</i> if this constant is lesser than or equal to the
     * constant zero, <i>false</i> otherwise.
     */
    @Override
    public boolean isNegativeOrZero() {
	return value <= 0f;
    }

    /**
     * Checks whether the value represented by this constant is numeric not equal to
     * the value represented by the other constant.
     * @param arg the other constant, whose value should be compared to this one.
     * @return <code>true</code> if the value rpresented by this constant is not equal
     * to the value of the other constant, <code>false</code> if the values are equal.
     */
    @Override
    public boolean isNotEqualTo(NumericConstant arg){
	if (arg instanceof DoubleConstant)
	    return value != arg.getDoubleValue();
	else
	    return value != arg.getFloatValue();
    }

    /**
     * Checks if this constant is equal to the constant value one.
     * @return <i>true</i> if this constant is equal to one, <i>false</i>
     * otherwise.
     */
    @Override
    public boolean isOne() {
	return value == 1f;
    }

    /**
     * Checks if this constant is greater than zero or not.
     * @return <i>true</i> if this constant is greater than the constant zero,
     * <i>false</i> otherwise.
     */
    @Override
    public boolean isPositive() {
	return value > 0f;
    }

    /**
     * Checks if this constant is greater than or equal to zero or not.
     * @return <i>true</i> if this constant is greater than or equal to the
     * constant zero, <i>false</i> otherwise.
     */
    @Override
    public boolean isPositiveOrZero() {
	return value >= 0f;
    }

    /**
     * Checks if this constant is equal to the constant value zero.
     * @return <i>true</i> if this constant is equal to zero, <i>false</i>
     * if it is any other value.
     */
    @Override
    public boolean isZero() {
	return (value == 0f) || (value == -0f);
    }

    /**
     * Returns the remainder of the division of this value by the passed one.
     * @param divisor the divisor of the remainder operation.
     * @return the remainder of the division of this value by the passed one.
     */
    @Override
    public NumericConstant modulo(NumericConstant divisor){
	if (divisor instanceof IntConstant || divisor instanceof LongConstant || divisor instanceof FloatConstant)
	    return FloatConstant.getInstance(value % divisor.getFloatValue());
	if (divisor instanceof DoubleConstant)
	    return DoubleConstant.getInstance(value % divisor.getDoubleValue());
	return null;
    }

    /**
     * Multiplies the passed constant with this constant.
     * @param factor the constant this constant should be multiplied with.
     * @return the product of the two constants.
     */
    @Override
    public NumericConstant multiply(NumericConstant factor) {
	if (factor instanceof DoubleConstant)
	    return factor.multiply(this);
	else
	    return getInstance(this.value * factor.getFloatValue());
    }

    /**
     * Returns a constant having the same magnitude as this constant but a
     * different sign.
     * @return the constant having the same magnitude as this constant but a
     * different sign.
     */
    @Override
    public NumericConstant negate() {
	return getInstance(-value);
    }

    @Override
    public NumericConstant next() {
	return getInstance(Float.intBitsToFloat((Float.floatToIntBits(value) + 1)));
    }

    /**
     * Throws an InternalError because there is no or operation for
     * floating point values defined in the java virtual machine specification.
     * @param constant unused.
     * @return nothing.
     * @throws InternalError
     */
    @Override
    public NumericConstant or(NumericConstant constant){
	throw new InternalError("| can not be applied to float and " + Term.getTypeName(constant.getType()));
    }

    @Override
    public NumericConstant pred() {
	return getInstance(Float.intBitsToFloat((Float.floatToIntBits(value) - 1)));
    }

    @Override
    public NumericConstant shiftLeft(int range) {
	throw new InternalError("Shifting not supported on floating point values");
    }

    /**
     * Subtracts the passed constant from this constant.
     * @param subtrahend the constant that should be subtracted.
     * @return the difference of the two constants.
     */
    @Override
    public NumericConstant subtract(NumericConstant subtrahend) {
	if (subtrahend instanceof DoubleConstant)
	    return DoubleConstant.getInstance(getDoubleValue() - subtrahend.getDoubleValue());
	else
	    return getInstance(this.value - subtrahend.getFloatValue());
    }

    @Override
    public String toHaskellString(){
	return "(Constant (FloatConst " + value + "))";
    }

    /**
     * Returns a string representation of the internally stored value of this
     * constant.
     * @param useInternalVariableNames if set to true the string representation
     * will be build using the internal names for each variable. Otherwise the
     * originally given names of the variables will be used.
     * @return the string representation of the internally stored value of this
     * constant.
     */
    public String toString(boolean useInternalVariableNames){
	return Float.toString(value);
    }

    /**
     * Throws an InternalError because there is no or operation for
     * floating point values defined in the java virtual machine specification.
     * @param constant unused.
     * @return nothing.
     * @throws InternalError
     */
    @Override
    public NumericConstant xor(NumericConstant constant){
	throw new InternalError("^ can not be applied to float and " + Term.getTypeName(constant.getType()));
    }
}
